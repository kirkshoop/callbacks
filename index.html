<!DOCTYPE html>
<html>
  <head>
    <title>Introduction to ReactiveX in C++ (rxcpp)</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="./fonts.css"/>
    <link rel="stylesheet" href="./mermaid.forest.css">
    <style>
        body { font-family: 'Droid Serif'; }
        h1, h2, h3 {
            font-family: 'Yanone Kaffeesatz';
            font-weight: normal;
        }
        .remark-code, .remark-inline-code { font-family: 'Droid Sans Mono'; }
        .remark-slide-content {
            padding-bottom: 4em;
        }
        div.footer {
            position: absolute;
            bottom: 12px;
            width: 100%;
            opacity: .6;
        }
        .footer .flexcontainer {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            margin-right: 175px;
        }

        .border {
            border: 2px solid steelblue;
        }

        div.emscripten-output {
            font-family: 'Droid Sans Mono';
            font-size: 14pt;
            border: 2px solid steelblue;
            padding: 5px;
            background: black;
            color: lightgreen;
        }

        table {
            border-collapse: collapse;
            width: 100%;
        }
        th, td {
            padding: 5px;
            border: 1px solid steelblue;
        }
        td {
            color: #7f0000;
        }
        th {
            border-bottom: 3px solid steelblue;
            color: black;
        }
        
        .green {
            color: seagreen
        }

        .column:first-of-type {float:left}
        .column:last-of-type {float:right}

        .split-30 .column:first-of-type {width: 30%}
        .split-30 .column:last-of-type {width: 70%}
        .split-40 .column:first-of-type {width: 40%}
        .split-40 .column:last-of-type {width: 60%}
        .split-50 .column:first-of-type {width: 50%}
        .split-50 .column:last-of-type {width: 50%}
        .split-60 .column:first-of-type {width: 60%}
        .split-60 .column:last-of-type {width: 40%}
        .split-70 .column:first-of-type {width: 70%}
        .split-70 .column:last-of-type {width: 30%}

        blockquote {
            background: lightgray ;
            border-left: 10px solid deepskyblue;
            margin: 1.5em 0px;
            padding: 0.5em 10px;
            quotes: "\201C""\201D""\2018""\2019";
        }
        blockquote:before {
            color: #ccc;
            font-size: 4em;
            line-height: 0.1em;
            margin-right: 0.25em;
            vertical-align: -0.4em;
        }
        blockquote p {
            display: inline;
        }

        .mermaid p {
            display: inline;
        }
        .mermaid svg {
          display: inline;
          margin: auto;
          max-height: 480px
        }
    </style>
  </head>
  <body>
    <textarea id="source">

layout: true
<div class="footer"><div class="flexcontainer"><span>.body[[https://kirkshoop.github.io/introductionToRxcpp](https://kirkshoop.github.io/introductionToRxcpp)]</span><span>.center[CERN 2017]</span><span>.body[&copy; 2017 Kirk Shoop ([github](http://github.com/kirkshoop) [twitter](http://twitter.com/kirkshoop))]</span></div></div>

---

class: middle

.center[

# Introduction to ReactiveX in C++ (rxcpp)

#### algorithms for values distributed in time

]

<rx-marbles key="debounce"/>

???

> * 

---

#### DEMO

.center[
![twitter application](content/twitter_with_word_sentiment.gif)
]

???

> * twitter stream api
> * sample of live tweets.
> * sentiment analysis 
> * words (wanna, love)

---

# a bird in hand is worth two in a bush

---

# a bird in hand is worth two in a bush

.center[
## data in the hand can be used now
array and list are values distributed in space
]

---

# a bird in hand is worth two in a bush

.center[
## data in the bush cannot be used now
user input and IO are values distributed in time
]

???

> * 
---

# my son says, space vs time is observed when playing cards

???

> * kiran's idea

---

# each player has 0 or more cards

.center[

![poker hand](content/poker-game-264599_1280.jpg)

## cards in the hand can be processed now

.green[
### array and list are values distributed in space
]

]

???

> * 

---

# the dealer distributes cards in time

.center[

![poker deck](content/poker-deck-875295_1280.jpg)

## cards in the deck cannot be processed now

.green[
### user input and IO are values distributed in time
]

]

???

> * 

---

```
observable | subscribe(subscriber);
```

.center[
.mermaid[
sequenceDiagram
participant observable
participant subscriber
participant App
App->> observable: subscribe(subscriber)
activate observable
note over observable,subscriber: calls to the subscriber must never overlap in time
loop value
    observable -->> subscriber: on_next()
end
alt failure
    observable --x subscriber: on_error()
else finish
    observable --x subscriber: on_completed()
end
subscriber -->> subscriber: unsubscribe()
deactivate observable
]
]

???

> *

---

```
range(2, 2) | rxo::map([](long l){return to_string(l);} | subscribe(); 
```

.center[
.mermaid[
sequenceDiagram
participant input observable
participant map subscriber
participant map observable
participant App subscriber
participant App
App ->> map observable: subscribe(App subscriber)
activate map observable
map observable ->> input observable: subscribe(map subscriber)
activate input observable
input observable -->> map subscriber: on_next(2)
map subscriber -->> App subscriber: on_next(to_string(2))
input observable --x map subscriber: on_completed()
map subscriber --x App subscriber: on_completed()
App subscriber -->> App subscriber: unsubscribe()
deactivate map observable
map subscriber -->> map subscriber: unsubscribe()
deactivate input observable
]
]

???

> *

---

# how to get a stream of tweets

--

```
auto tweetthread = observe_on_new_thread();
```

--

```
auto requesttwitterstream = defer([=](){
    auto url = oauth2SignUrl("https://stream.twitter.com/...");
```

???

> * defer is used to call oauth2SignUrl when the request is repeated

--

```
    return http.create(http_request{url, method, {}, {}}) |
```

--

```
        rxo::map([](http_response r){
            return r.body.chunks;
        }) |
```

???

> * only keep the strings from the request body

--

```
        merge(tweetthread);
}) |
```

--

```
twitter_stream_reconnection(tweetthread);
```

???

> * twitter_stream_reconnection - new operator to retry the request on failure

---

# how to handle twitter retry protocol

--

```
auto twitter_stream_reconnection = [](observe_on_one_worker tweetthread){
    return [=](observable<string> chunks){
        return chunks |
```

???

> * an operator is a function that takes an observable and returns an observable

--

```
            timeout(seconds(90), tweetthread) |
```

???

> * error when no string has been appended to the body in 90s 

--

```
            on_error_resume_next([=](exception_ptr ep) {
                try {rethrow_exception(ep);
                } catch (const http_exception& ex) {
                    return twitterRetryAfterHttp(ex);
                } catch (const timeout_error& ex) {
                    return empty<string>();
                }
                return error<string>(ep, tweetthread);
            }) |
```

???

> * catches errors and returns a new observable to use
> * the returned observable might complete instantly
> * the returned observable might complete after a delay

--

```
            repeat(0);
}; };
```

???

> * when the chunks observable is completed, make a new http request.

---

# how to call sentiment web service

```
auto requestsentiment = observable<>::defer([=]() {
```

--

```
    std::map<string, string> headers;
    headers["Content-Type"] = "application/json";
    headers["Authorization"] = "Bearer " + key;
```

--

```
    auto body = json::parse(
        R"({"Inputs":{"input1":[{"tweet_text": "Hi!"}]},"GlobalParameters":{}})"
    );
```

--

```
    return http.create(http_request{url, "POST", headers, body.dump()}) |
        rxo::map([](http_response r){
            return r.body.complete;
        }) |
        merge(workerthread);
});
```

???

> * 

---

# rxcpp architechture

.mermaid[
classDiagram
    subscription --o subscriber : 1
    observer --o subscriber : 1
    subscription : bool is_subscribed()
    subscription : void unsubscribe()
    observer : void on_next(T)
    observer : void on_error(exception_ptr)
    observer : void on_completed()
    subscriber : subscription get_subscription()
    subscriber : observer get_observer()
    subscriber : void on_next(T)
    subscriber : void on_error(exception_ptr)
    subscriber : void on_completed()
    subscriber : bool is_subscribed()
    subscriber : void unsubscribe()
    observable o-- subscriber : 0..n
    observable : subscription subscribe(subscriber)
]

???

> *

---

# rxcpp scheduler architechture

.mermaid[
classDiagram
    action --o schedulable : 1
    subscription --o worker : 1
    subscription --o schedulable : 1
    subscription : bool is_subscribed()
    subscription : void unsubscribe()
    action : void operator()()
    schedulable : subscription get_subscription()
    schedulable : action get_schedulable()
    scheduler -- worker
    worker o-- schedulable : 0..n
    scheduler : time_point now()
    scheduler : worker create_worker(subscription)
    worker : scheduler get_scheduler()
    worker : time_point now()
    worker : subscription schedule(time_point at, schedulable)
]

???

> *

---

##complete.
questions?

<rx-marbles key="concat"/>
???
> * 

    </textarea>
    <!--script src="https://gnab.github.io/remark/downloads/remark-latest.min.js" type="text/javascript" >
    </script-->
    <script src="./remark-latest.min.js" type="text/javascript" >
    </script>
    <script src="./CustomElements.min.js" type="text/javascript" >
    </script>
    <script src="./element.js" type="text/javascript" >
    </script>
    <script>
        var Module = {noInitialRun: false};
        var printTo = function(output) {
            return function(text){
                if (output) {
                    text = text.replace(/&/g, "&amp;");
                    text = text.replace(/</g, "&lt;");
                    text = text.replace(/>/g, "&gt;");
                    text = text.replace('\n', '<br>', 'g');
                    output.innerHTML += text + "<br>";
                }
            };
        };
    </script>
    <script src="./mermaid.js"></script>
    <!--script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&delayStartupUntil=configured" type="text/javascript" >
    </script-->
    <script src="./MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML&delayStartupUntil=configured" type="text/javascript" >
    </script>
    <script>
        var slideshow = remark.create({
            ratio: "16:9",
            highlightLanguage: "cpp",
            highlightStyle: "tomorrow",
            highlightSpans: true
        });

        mermaid.initialize({
          mermaid: {
            startOnLoad: false,
            cloneCssStyles: false
          }
        });

        function initMermaid(slide) {
          try {
            mermaid.init(undefined, '.remark-visible .mermaid p');
          } catch(e) {
            console.log(e);
          }
        }
        initMermaid(slideshow.getSlides()[slideshow.getCurrentSlideIndex()]);

        MathJax.Hub.Config({
            displayAlign: "left",
            tex2jax: {
                skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                inlineMath: [['$','$'], ['\\(','\\)']]
            }
        });
        MathJax.Hub.Configured();
        // mathjax examples 

        // `$$ x = (-b +- sqrt(b^2-4ac))/(2a) . $$`

        // `$$ \int_{V_1}^{V_2}mVdV =  \int_{s_1}^{s_2} F_s ds $$`

        // `$$
        // A \xrightarrow{send} B
        // $$`

        // `$$
        // \newcommand{\ra}[1]{\!\!\!\!\!\!\!\!\!\!\!\!\xrightarrow{\quad#1\quad}\!\!\!\!\!\!\!\!}
        // \newcommand{\da}[1]{\left\downarrow{\scriptstyle#1}\vphantom{\displaystyle\int_0^1}\right.}
        // %
        // \begin{array}{llllllllllll}
        // 0 & \ra{f_1} & A & \ra{f_2} & B & \ra{f_3} & C & \ra{f_4} & D & \ra{f_5} & 0 \\
        // \da{g_1} & & \da{g_2} & & \da{g_3} & & \da{g_4} & & \da{g_5} & & \da{g_6} \\
        // 0 & \ra{h_1} & 0 & \ra{h_2} & E & \ra{h_3} & F & \ra{h_4} & 0 & \ra{h_5} & 0 \\
        // \end{array}
        // $$`

        var modules = {};

        slideshow.on("showSlide", function(slide) {
            if (!!slide.properties.function){
                var m = (slide.properties.module || "").split('>');
                var f = slide.properties.function.split('>');
                var r = (slide.properties.return || "").split('>');
                var t = (slide.properties.types || "").split('>');
                var a = (slide.properties.arguments || "").split('>');
                var o = slide.properties.output.split('>');
                f.map((func, i) => {
                    var output = document.getElementById(o[i]);
                    if (output) output.innerHTML = ''; // clear contents
                    var module = modules[m[i]];
                    module["print"] = printTo(output);
                    module.ccall(
                        func, // C function
                        (r[i] || "") == "" ? null : r[i], // return type
                        t[i].split(','), // argument types
                        a[i].split(',')) // arguments
                });
            }
        });
        slideshow.on("afterShowSlide", function(slide) {
            initMermaid(slide);
        });
        slideshow.on("hideSlide", function(slide) {
            Object.keys(modules).map(k =>  modules[k].ccall('reset', null, [], []));
        });
    </script>
  </body>
</html>
